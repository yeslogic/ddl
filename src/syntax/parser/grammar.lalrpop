use std::iter;

use lalrpop_util::ParseError::User as UserError;
use name::Named;
use source::{BytePos, Span};
use syntax::ast::{Definition, Field, Program};
use syntax::ast::binary;
use syntax::ast::host::{self, Binop, Const, Unop};
use syntax::parser::GrammarError;
use syntax::parser::lexer::Token;
use var::Var;


grammar<'input>();


// Tokens

extern {
    type Location = BytePos;
    type Error = GrammarError;

    enum Token<'input> {
        // Data
        "Ident" => Token::Ident(<&'input str>),
        "DocComment" => Token::DocComment(<&'input str>),
        "BinLiteral" => Token::BinLiteral(<u64>, <&'input str>),
        "HexLiteral" => Token::HexLiteral(<u64>, <&'input str>),
        "DecLiteral" => Token::DecLiteral(<u64>, <&'input str>),
        "FloatDecLiteral" => Token::FloatDecLiteral(<f64>, <&'input str>),

        // Keywords
        "as" => Token::As,
        "cond" => Token::Cond,
        "compute" => Token::Compute,
        "from" => Token::From,
        "struct" => Token::Struct,
        "union" => Token::Union,
        "where" => Token::Where,

        // Symbols
        "&" => Token::Amp,
        "&&" => Token::AmpAmp,
        "!" => Token::Bang,
        "!=" => Token::BangEqual,
        ":" => Token::Colon,
        "," => Token::Comma,
        "." => Token::Dot,
        "=" => Token::Equal,
        "==" => Token::EqualEqual,
        "=>" => Token::EqualGreater,
        "/" => Token::ForwardSlash,
        ">" => Token::Greater,
        ">=" => Token::GreaterEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,
        "-" => Token::Minus,
        "|" => Token::Pipe,
        "||" => Token::PipePipe,
        "+" => Token::Plus,
        ";" => Token::Semi,
        "*" => Token::Star,

        // Delimeters
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
    }
}


pub Program: Program = {
    <defs: Definition*> => {
        Program::new(defs)
    },
};

Definition: Definition = {
    <doc: "DocComment"*> <name: "Ident"> "=" <ty: PrimaryBinaryType> ";" => {
        Definition {
            doc: doc.join("\n").into(),
            name: name.to_owned(),
            ty,
        }
    },
    <doc: "DocComment"*> <name: "Ident"> <lo: @L>
        "(" <params: (<"Ident"> ",")*> <last: "Ident"> ")" "="
        <body_ty: PrimaryBinaryType> <hi: @R> ";" =>
    {
        let params = params
            .into_iter()
            .chain(iter::once(last))
            .collect::<Vec<_>>();

        Definition {
            doc: doc.join("\n").into(),
            name: name.to_owned(),
            ty: binary::Type::abs(Span::new(lo, hi), &params, body_ty).into(),
        }
    },
};

Field<Value>: Field<Value> = {
    <doc: "DocComment"*> <name: "Ident"> ":" <value: Value> => {
        Field {
            doc: doc.join("\n").into(),
            name: name.to_owned(),
            value: value,
        }
    },
};


// Binary Types

pub BinaryType: binary::RcType = {
    <ty: PrimaryBinaryType> => ty,
};

PrimaryBinaryType: binary::RcType = {
    AtomicBinaryType,
    <lo1: @L> <ty: PrimaryBinaryType> "where" <lo2: @L> <param: "Ident"> "=>" <pred: PrimaryHostExpr> <hi: @R> => {
        let repr_ty = ty.repr();
        let pred_expr = host::Expr::abs(
            Span::new(lo2, hi),
            vec![Named(param.to_owned(), repr_ty)],
            pred,
        );

        binary::Type::Assert(Span::new(lo1, hi), ty, pred_expr.into()).into()
    },
    <lo: @L> "compute" <repr_ty: HostType> "from" <expr: PrimaryHostExpr> <hi: @R> => {
        let empty = binary::Type::Const(binary::TypeConst::Empty);
        let conv = host::Expr::abs(
            Span::new(lo, hi),
            vec![Named("_".to_owned(), empty.repr())],
            expr,
        );

        binary::Type::Interp(Span::new(lo, hi), empty.into(), conv.into(), repr_ty).into()
    },
};

AtomicBinaryType: binary::RcType = {
    <lo: @L> <name: "Ident"> <hi: @R> => {
        binary::Type::Var(Span::new(lo, hi), Var::free(name)).into()
    },
    <lo: @L> <ty: AtomicBinaryType> "(" <arg_tys: (<BinaryType> ",")*> <last: BinaryType> ")" <hi: @R> => {
        let mut arg_tys = arg_tys;
        arg_tys.push(last);
        binary::Type::App(Span::new(lo, hi), ty, arg_tys).into()
    },
    "(" <ty: PrimaryBinaryType> ")" => ty,
    <lo: @L> "struct" "{"
        <fields: (<Field<BinaryType>> ",")*>
        <last: Field<BinaryType>?>
    "}" <hi: @R> =>
    {
        let mut fields = fields;
        fields.extend(last);
        binary::Type::struct_(Span::new(lo, hi), fields).into()
    },
    <lo: @L> "cond" "{"
        <options: (<Field<(<HostExpr> "=>" <BinaryType>)>> ",")*>
        <last: Field<(<HostExpr> "=>" <BinaryType>)>?>
    "}" <hi: @R> =>
    {
        let mut options = options;
        options.extend(last);
        binary::Type::Cond(Span::new(lo, hi), options).into()
    },
    <lo: @L> "[" <elem: PrimaryBinaryType> ";" <size: PrimaryHostExpr> "]" <hi: @R> => {
        binary::Type::Array(Span::new(lo, hi), elem, size).into()
    },
};


// Host Types

pub HostType: host::RcType = {
    // FIXME: implement full host type parsing, with proper name binding
    //
    // We'll just hard-code identifiers for now
    <name: "Ident"> =>? {
        let ty_const = super::parse_ty_const(name).map_err(|error| UserError { error })?;

        Ok(host::Type::Const(ty_const).into())
    },
};


// Host Expressions

pub HostExpr: host::RcExpr = {
    <expr: PrimaryHostExpr> => expr,
};

// Unary operators

UnopNeg: Unop = "-" => Unop::Neg;
UnopNot: Unop = "!" => Unop::Not;

UnopExpr<Op, Operand>: host::RcExpr = {
    <lo: @L> <op: Op> <expr: Operand> <hi: @R> => {
        host::Expr::Unop(Span::new(lo, hi), op, expr).into()
    },
};

// Binary operators

BinopOr:   Binop = "||"  => Binop::Or;
BinopAnd:  Binop = "&&"  => Binop::And;
BinopEq:   Binop = "=="  => Binop::Eq;
BinopNe:   Binop = "!="  => Binop::Ne;
BinopLe:   Binop = "<="  => Binop::Le;
BinopLt:   Binop = "<"   => Binop::Lt;
BinopGt:   Binop = ">"   => Binop::Gt;
BinopGe:   Binop = ">="  => Binop::Ge;
BinopAdd:  Binop = "+"   => Binop::Add;
BinopSub:  Binop = "-"   => Binop::Sub;
BinopMul:  Binop = "*"   => Binop::Mul;
BinopDiv:  Binop = "/"   => Binop::Div;

BinopExpr<Lhs, Op, Rhs>: host::RcExpr = {
    <lo: @L> <lhs: Lhs> <op: Op> <rhs: Rhs> <hi: @R> => {
        host::Expr::Binop(Span::new(lo, hi), op, lhs, rhs).into()
    },
};

// Use precedence climbing to define the operators
// https://en.wikipedia.org/wiki/Operator-precedence_parser#Precedence_climbing_method

PrimaryHostExpr: host::RcExpr = {
    EqHostExpr,
    BinopExpr<EqHostExpr, BinopOr, PrimaryHostExpr>,
    BinopExpr<EqHostExpr, BinopAnd, PrimaryHostExpr>,
};

EqHostExpr: host::RcExpr = {
    CmpHostExpr,
    BinopExpr<CmpHostExpr, BinopEq, EqHostExpr>,
    BinopExpr<CmpHostExpr, BinopNe, EqHostExpr>,
};

CmpHostExpr: host::RcExpr = {
    AddHostExpr,
    BinopExpr<AddHostExpr, BinopLe, CmpHostExpr>,
    BinopExpr<AddHostExpr, BinopLt, CmpHostExpr>,
    BinopExpr<AddHostExpr, BinopGt, CmpHostExpr>,
    BinopExpr<AddHostExpr, BinopGe, CmpHostExpr>,
};

AddHostExpr: host::RcExpr = {
    MulHostExpr,
    BinopExpr<MulHostExpr, BinopAdd, AddHostExpr>,
    BinopExpr<MulHostExpr, BinopSub, AddHostExpr>,
};

MulHostExpr: host::RcExpr = {
    CastHostExpr,
    BinopExpr<CastHostExpr, BinopMul, MulHostExpr>,
    BinopExpr<CastHostExpr, BinopDiv, MulHostExpr>,
};

CastHostExpr: host::RcExpr = {
    PrefixHostExpr,
    <lo: @L> <expr: CastHostExpr> "as" <ty: HostType> <hi: @R> => {
        host::Expr::Cast(Span::new(lo, hi), expr, ty).into()
    },
};

PrefixHostExpr: host::RcExpr = {
    AtomicHostExpr,
    UnopExpr<UnopNeg, AtomicHostExpr>,
    UnopExpr<UnopNot, AtomicHostExpr>,
};

IntLiteral<Value>: host::RcExpr = {
    <lo: @L> <value: Value> <hi: @R> =>? {
        use syntax::ast::host::IntType;

        let int = Const::Int(value.0, match value.1 {
            "i8" => Some(IntType::i8()),
            "i16" => Some(IntType::i16()),
            "i24" => Some(IntType::i24()),
            "i32" => Some(IntType::i32()),
            "i64" => Some(IntType::i64()),
            "u8" => Some(IntType::u8()),
            "u16" => Some(IntType::u16()),
            "u24" => Some(IntType::u24()),
            "u32" => Some(IntType::u32()),
            "u64" => Some(IntType::u64()),
            "" => None,
            s => return Err(UserError {
                error: GrammarError::ConstSuffixInvalid {
                    suffix: s.to_owned(),
                },
            }),
        });

        Ok(host::Expr::Const(Span::new(lo, hi), int).into())
    },
};

FloatLiteral<Value>: host::RcExpr = {
    <lo: @L> <value: Value> <hi: @R> =>? {
        use syntax::ast::host::FloatType;

        let float = Const::Float(value.0, match value.1 {
            "f32" => FloatType::F32,
            "f64" => FloatType::F64,
            "" => return Err(UserError { error: GrammarError::ConstSuffixMissing }),
            s => return Err(UserError {
                error: GrammarError::ConstSuffixInvalid {
                    suffix: s.to_owned(),
                },
            }),
        });

        Ok(host::Expr::Const(Span::new(lo, hi), float).into())
    },
};

AtomicHostExpr: host::RcExpr = {
    "(" <expr: PrimaryHostExpr> ")" => expr,

    IntLiteral<"BinLiteral">,
    IntLiteral<"HexLiteral">,
    IntLiteral<"DecLiteral">,
    FloatLiteral<"FloatDecLiteral">,

    <lo: @L> <name: "Ident"> <hi: @R> => {
        host::Expr::Var(Span::new(lo, hi), Var::free(name)).into()
    },
    <lo: @L> <struct_expr: AtomicHostExpr> "." <field_name: "Ident"> <hi: @R> => {
        host::Expr::Proj(Span::new(lo, hi), struct_expr, field_name.into()).into()
    },
    <lo: @L> <array_expr: AtomicHostExpr> "[" <index_expr: PrimaryHostExpr> "]" <hi: @R> => {
        host::Expr::Subscript(Span::new(lo, hi), array_expr, index_expr).into()
    },
};
