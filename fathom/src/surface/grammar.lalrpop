use scoped_arena::Scope;
use std::cell::RefCell;

use crate::source::{FileRange, BytePos, StringId, StringInterner};
use crate::surface::{
    Arg, BinOp, ExprField, FormatField, Item, ItemDef, Module, ParseMessage,
    Pattern, Param, Plicity, Term, TypeField,
};
use crate::surface::lexer::{Error as LexerError, Token};
use crate::files::FileId;

grammar<'arena, 'source>(
    interner: &RefCell<StringInterner>,
    scope: &'arena Scope<'arena>,
    messages: &mut Vec<ParseMessage>,
    file_id: FileId,
);

extern {
    type Location = BytePos;
    type Error = LexerError;

    enum Token<'source> {
        "name" => Token::Name(<&'source str>),
        "hole" => Token::Hole(<&'source str>),
        "string literal" => Token::StringLiteral(<&'source str>),
        "number literal" => Token::NumberLiteral(<&'source str>),

        "def" => Token::KeywordDef,
        "else" => Token::KeywordElse,
        "fun" => Token::KeywordFun,
        "if" => Token::KeywordIf,
        "let" => Token::KeywordLet,
        "match" => Token::KeywordMatch,
        "overlap" => Token::KeywordOverlap,
        "Type" => Token::KeywordType,
        "then" => Token::KeywordThen,
        "true" => Token::KeywordTrue,
        "false" => Token::KeywordFalse,
        "where" => Token::KeywordWhere,

        "@" => Token::At,
        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Equals,
        "=>" => Token::EqualsGreater,
        "." => Token::FullStop,
        "/" => Token::ForwardSlash,
        "->" => Token::HyphenGreater,
        "<-" => Token::LessHyphen,
        "-" => Token::Minus,
        "|" => Token::Pipe,
        "+" => Token::Plus,
        ";" => Token::Semicolon,
        "*" => Token::Star,
        "_" => Token::Underscore,

        "!=" => Token::BangEquals,
        "==" => Token::EqualsEquals,
        ">=" => Token::GreaterEquals,
        ">" => Token::Greater,
        "<=" => Token::LessEquals,
        "<" => Token::Less,

        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
    }
}

pub Module: Module<'arena, FileRange> = {
    <items: Item*> => Module {
        items: scope.to_scope_from_iter(items.into_iter()),
    },
};

Item: Item<'arena, FileRange> = {
    <start: @L> "def" <label: RangedName> <params: Param*> <r#type: (":" <LetTerm>)?> "=" <expr: Term> ";" <end: @R> => {
        Item::Def(ItemDef {
            range: FileRange::new(file_id, start, end),
            label,
            params: scope.to_scope_from_iter(params),
            r#type: r#type.map(|r#type| scope.to_scope(r#type) as &_),
            expr: scope.to_scope(expr),
        })
    },
    <start: @L> <error: !> <end: @R> => {
        messages.push(ParseMessage::from_lalrpop_recovery(file_id, error));
        Item::ReportedError(FileRange::new(file_id, start, end))
    },
};

Pattern: Pattern<FileRange> = {
    <start: @L> <name: Name> <end: @R> => Pattern::Name(FileRange::new(file_id, start, end), name),
    <start: @L> "_" <end: @R> => Pattern::Placeholder(FileRange::new(file_id, start, end)),
    <start: @L> <string: StringLiteral> <end: @R> => Pattern::StringLiteral(FileRange::new(file_id, start, end), string),
    <start: @L> <number: NumberLiteral> <end: @R> => Pattern::NumberLiteral(FileRange::new(file_id, start, end), number),
    <start: @L> "true" <end: @R> => Pattern::BooleanLiteral(FileRange::new(file_id, start, end), true),
    <start: @L> "false" <end: @R> => Pattern::BooleanLiteral(FileRange::new(file_id, start, end), false),
};

pub Term: Term<'arena, FileRange> = {
    LetTerm,
    <start: @L> <expr: LetTerm> ":" <r#type: LetTerm> <end: @R> => {
        Term::Ann(
            FileRange::new(file_id, start, end),
            scope.to_scope(expr),
            scope.to_scope(r#type),
        )
    },
};

LetTerm: Term<'arena, FileRange> = {
    FunTerm,
    <start: @L> "let" <def_pattern: Pattern> <def_type: (":" <LetTerm>)?> "=" <def_expr: Term> ";" <body_expr: LetTerm> <end: @R> => {
        Term::Let(
            FileRange::new(file_id, start, end),
            def_pattern,
            def_type.map(|def_type| scope.to_scope(def_type) as &_),
            scope.to_scope(def_expr),
            scope.to_scope(body_expr),
        )
    },
    <start: @L> "if" <cond_expr: FunTerm> "then" <then_expr: LetTerm> "else" <else_expr: LetTerm> <end: @R> => {
        Term::If(FileRange::new(file_id, start, end), scope.to_scope(cond_expr), scope.to_scope(then_expr), scope.to_scope(else_expr))
    },
};

FunTerm: Term<'arena, FileRange> = {
    EqExpr,
    <start: @L> <plicity: Plicity> <param_type: AppTerm> "->"  <body_type: FunTerm> <end: @R> => {
        Term::Arrow(
            FileRange::new(file_id, start, end),
            plicity,
            scope.to_scope(param_type),
            scope.to_scope(body_type),
        )
    },
    <start: @L> "fun" <params: Param+> "->"  <output_type: FunTerm> <end: @R> => {
        Term::FunType(
            FileRange::new(file_id, start, end),
            scope.to_scope_from_iter(params),
            scope.to_scope(output_type),
        )
    },
    <start: @L> "fun" <params: Param+> "=>" <output_type: LetTerm> <end: @R> => {
        Term::FunLiteral(
            FileRange::new(file_id, start, end),
            scope.to_scope_from_iter(params),
            scope.to_scope(output_type),
        )
    },
};

EqExpr: Term<'arena, FileRange> = {
    CmpExpr,
    BinExpr<CmpExpr, BinOpEq, EqExpr>,
    BinExpr<CmpExpr, BinOpNeq, EqExpr>,
};

CmpExpr: Term<'arena, FileRange> = {
    AddExpr,
    BinExpr<AddExpr, BinOpLt, CmpExpr>,
    BinExpr<AddExpr, BinOpLte, CmpExpr>,
    BinExpr<AddExpr, BinOpGt, CmpExpr>,
    BinExpr<AddExpr, BinOpGte, CmpExpr>,
};

AddExpr: Term<'arena, FileRange> = {
    MulExpr,
    BinExpr<MulExpr, BinOpAdd, AddExpr>,
    BinExpr<MulExpr, BinOpSub, AddExpr>,
};

MulExpr: Term<'arena, FileRange> = {
    AppTerm,
    BinExpr<AppTerm, BinOpMul, MulExpr>,
    BinExpr<AppTerm, BinOpDiv, MulExpr>,
};

AppTerm: Term<'arena, FileRange> = {
    ProjTerm,
    <start: @L> <head_expr: ProjTerm> <args: Arg+> <end: @R> => {
        Term::App(
            FileRange::new(file_id, start, end),
            scope.to_scope(head_expr),
            scope.to_scope_from_iter(args),
        )
    },
};

ProjTerm: Term<'arena, FileRange> = {
    AtomicTerm,
    <start: @L> <head_expr: AtomicTerm> <labels: ("." <RangedName>)+> <end: @R> => {
        Term::Proj(
            FileRange::new(file_id, start, end),
            scope.to_scope(head_expr),
            scope.to_scope_from_iter(labels),
        )
    },
};

AtomicTerm: Term<'arena, FileRange> = {
    <start: @L> "(" <term: Term> ")" <end: @R> => term,
    <start: @L> <terms: Tuple<Term>> <end: @R> => Term::Tuple(FileRange::new(file_id, start, end), terms),

    <start: @L> <name: Name> <end: @R> => Term::Name(FileRange::new(file_id, start, end), name),
    <start: @L> "_" <end: @R> => Term::Placeholder(FileRange::new(file_id, start, end)),
    <start: @L> <name: Hole> <end: @R> => Term::Hole(FileRange::new(file_id, start, end), name),
    <start: @L> "match" <scrutinee: ProjTerm> "{"  <equations: Seq<(<Pattern> "=>" <Term>), ",">> "}" <end: @R> => {
        Term::Match(FileRange::new(file_id, start, end), scope.to_scope(scrutinee), equations)
    },
    <start: @L> "Type" <end: @R> => Term::Universe(FileRange::new(file_id, start, end)),
    <start: @L> <string: StringLiteral> <end: @R> => Term::StringLiteral(FileRange::new(file_id, start, end), string),
    <start: @L> <number: NumberLiteral> <end: @R> => Term::NumberLiteral(FileRange::new(file_id, start, end), number),
    <start: @L> "true" <end: @R> => Term::BooleanLiteral(FileRange::new(file_id, start, end), true),
    <start: @L> "false" <end: @R> => Term::BooleanLiteral(FileRange::new(file_id, start, end), false),
    <start: @L> "{" "}" <end: @R> => Term::Tuple(FileRange::new(file_id, start, end), &[]),
    <start: @L> "{" <fields: Seq1<TypeField, ",">> "}" <end: @R> => {
        Term::RecordType(FileRange::new(file_id, start, end), fields)
    },
    <start: @L> "{" <fields: Seq1<ExprField, ",">> "}" <end: @R> => {
        Term::RecordLiteral(FileRange::new(file_id, start, end), fields)
    },
    <start: @L> "{" <fields: Seq1<FormatField, ",">> "}" <end: @R> => {
        Term::FormatRecord(FileRange::new(file_id, start, end), fields)
    },
    <start: @L> "{" <name: RangedName> "<-" <format:Term> "|" <cond:Term> "}" <end: @R> => {
        Term::FormatCond(FileRange::new(file_id, start, end), name, scope.to_scope(format), scope.to_scope(cond))
    },
    <start: @L> "overlap" "{" <fields: Seq1<FormatField, ",">> "}" <end: @R> => {
        Term::FormatOverlap(FileRange::new(file_id, start, end), fields)
    },
    <start: @L> "[" <exprs: Seq<Term, ",">> "]" <end: @R> => {
        Term::ArrayLiteral(FileRange::new(file_id, start, end), exprs)
    },
    <start: @L> <error: !> <end: @R> => {
        messages.push(ParseMessage::from_lalrpop_recovery(file_id, error));
        Term::ReportedError(FileRange::new(file_id, start, end))
    },
};

FormatField: FormatField<'arena, FileRange> = {
    <label: RangedName> "<-" <format: Term> <pred: ("where" <Term>)?> => {
        FormatField::Format { label, format, pred }
    },
    "let" <label: RangedName> <r#type: (":" <Term>)?> "=" <expr: Term> => {
        FormatField::Computed { label, r#type, expr }
    },
};

TypeField: TypeField<'arena, FileRange> = {
    <label: RangedName> ":" <r#type: Term> => TypeField { label, r#type },
};

ExprField: ExprField<'arena, FileRange> = {
    <label: RangedName> "=" <expr: Term> => ExprField { label, expr },
};

BinExpr<Lhs, Op, Rhs>: Term<'arena, FileRange> = {
    <start: @L> <lhs: Lhs> <op: Op> <rhs: Rhs> <end: @R> => {
        Term::BinOp(
            FileRange::new(file_id, start, end),
            scope.to_scope(lhs),
            op,
            scope.to_scope(rhs),
        )
    },
};

BinOpAdd: BinOp<FileRange> = <start: @L> "+" <end: @R> => BinOp::Add(FileRange::new(file_id, start, end));
BinOpSub: BinOp<FileRange> = <start: @L> "-" <end: @R> => BinOp::Sub(FileRange::new(file_id, start, end));
BinOpMul: BinOp<FileRange> = <start: @L> "*" <end: @R> => BinOp::Mul(FileRange::new(file_id, start, end));
BinOpDiv: BinOp<FileRange> = <start: @L> "/" <end: @R> => BinOp::Div(FileRange::new(file_id, start, end));

BinOpEq: BinOp<FileRange> = <start: @L> "==" <end: @R> => BinOp::Eq(FileRange::new(file_id, start, end));
BinOpNeq: BinOp<FileRange> = <start: @L> "!=" <end: @R> => BinOp::Neq(FileRange::new(file_id, start, end));
BinOpLt: BinOp<FileRange> = <start: @L> "<" <end: @R> => BinOp::Lt(FileRange::new(file_id, start, end));
BinOpLte: BinOp<FileRange> = <start: @L> "<=" <end: @R> => BinOp::Lte(FileRange::new(file_id, start, end));
BinOpGt: BinOp<FileRange> = <start: @L> ">" <end: @R> => BinOp::Gt(FileRange::new(file_id, start, end));
BinOpGte: BinOp<FileRange> = <start: @L> ">=" <end: @R> => BinOp::Gte(FileRange::new(file_id, start, end));

#[inline] Name: StringId = { <"name"> => interner.borrow_mut().get_or_intern(<>) };
#[inline] Hole: StringId = { <"hole"> => interner.borrow_mut().get_or_intern(<>) };
#[inline] StringLiteral: StringId = { <"string literal"> => interner.borrow_mut().get_or_intern(<>) };
#[inline] NumberLiteral: StringId = { <"number literal"> => interner.borrow_mut().get_or_intern(<>) };

Tuple<Elem>: &'arena [Elem] = {
    "(" ")" => &[],
    "(" <term: Term> "," ")" => scope.to_scope_from_iter([term]),
    "(" <terms: Seq2<Term, ",">> ")" => terms,
};

#[inline]
Plicity: Plicity = {
    () => Plicity::Explicit,
    "@" => Plicity::Implicit,
};

Param: Param<'arena, FileRange> = {
    <plicity: Plicity> <pattern: Pattern> => Param { plicity, pattern, r#type: None },
    "(" <plicity: Plicity> <pattern: Pattern> ":" <r#type: LetTerm> ")" => Param { plicity, pattern, r#type: Some(r#type) },
};

Arg: Arg<'arena, FileRange> = {
    <plicity: Plicity> <term: ProjTerm> => Arg {plicity, term},
};

#[inline]
RangedName: (FileRange, StringId) = {
    <start: @L> <name: Name> <end: @R> => (FileRange::new(file_id, start, end), name),
};

Seq<Elem, Sep>: &'arena [Elem] = {
    <elems: (<Elem> Sep)*> <last: Elem?> => {
        scope.to_scope_from_iter(elems.into_iter().chain(last))
    }
};

Seq1<Elem, Sep>: &'arena [Elem] = {
    <first: Elem> <elems: (Sep <Elem>)*> Sep? => {
        scope.to_scope_from_iter(std::iter::once(first).chain(elems))
    },
};

Seq2<Elem, Sep>: &'arena [Elem] = {
    <first: Elem> Sep <second: Elem> <elems: (Sep <Elem>)*> Sep? => {
        scope.to_scope_from_iter(std::iter::once(first).chain(std::iter::once(second)).chain(elems))
    },
};
